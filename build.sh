#!/bin/bash
# Nixobolus - Automated creation of bootable NixOS images
# https://github.com/ponkila/Nixobolus

# Define variables
SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
NIXPKGS_REPO="https://github.com/NixOS/nixpkgs/archive/refs/heads/nixos-unstable.zip"
HM_REPO="https://github.com/nix-community/home-manager/archive/master.tar.gz"
config_dir="$SCRIPT_DIR/configs/nix_configs/hosts"
output_dir="$SCRIPT_DIR/result"
verbose=false
keep_configs=false
prompt=false

# Help message
help() {
    echo "Usage: ./build.sh [-p] [-k] [-o output_dir] [config_file]"
    echo ""
    echo "Options:"
    echo "-p, --prompt          Prompt before performing crucial actions (e.g. overwriting or deleting files)"
    echo "-k, --keep-configs    Keep intermediate nix configurations generated by Nixobolus"
    echo "-o, --output          Specify output directory (default: './result')"
    echo ""
    echo "If config_file is not specified, the script will read from standard input."
    echo "Config files should be in YAML or JSON format and be formatted correctly."
    exit 0
}

# Handles messages and prompts
say() {
    local message="$1"

    # [-] Check for error message
    if [[ "$message" =~ \[\-\] ]]; then
        echo -e "$message" >&2
        exit 1

    # [?] Prompt for user input
    elif [[ "$message" =~ \[\?\] ]]; then
        if [ "$prompt" == true ]; then
            echo ""
            read -r -p "$message" choice
        else
            choice="y"
        fi
        if [ "$choice" != "y" ]; then
            return 1
        else
            return 0
        fi

    # [+] Print message if verbose mode is on
    elif [ "$verbose" == true ]; then
        echo -e "$message"
    fi
}

# Check main dependencies (nix, python, jinja2)
check_deps() {
    # Check if nix-build is available
    if ! command -v nix-build >/dev/null 2>&1; then
        say "[-] Nix package manager is not installed."
    fi

    # Check if python is installed
    if command -v python3 >/dev/null 2>&1 ; then
        python_cmd="python3"
    elif command -v python >/dev/null 2>&1 ; then
        python_cmd="python"
    else
        say "[-] Python is not installed."
    fi

    # Check that python can import jinja2
    if ! $python_cmd -c "import jinja2" >/dev/null 2>&1; then
        say "[-] Jinja2 is not installed."
    fi
}

# Parse the command line options
parse_args() {
    while [[ "$#" -gt 0 ]]; do
        case $1 in
            -p|--prompt) prompt=true ;;
            -k|--keep-configs) keep_configs=true ;;
            -o|--output) output_dir="$2"; shift ;;
            -h|--help) help ;;
            -v|--verbose) verbose=true ;;
            -h|--help) help;;
            *.yml|*.yaml|*.json)
                config_file="$1"
                ;;
            *) say "[-] Unrecognized option '$1'"
            ;;
        esac
        shift
    done
}

# Read standard input
get_stdin() {
    # Read from stdin and store it in the temporary file
    temp_file="$(mktemp)"
    cat > "$temp_file"
    config_file="$temp_file"
}

# Get filetype (yaml or json)
get_filetype() {
    local file=$1
    local basename="${file##*/}"
    local firstline
    filetype="${basename##*.}"

    # Try to detect the filetype by first line
    if ! [[ "$filetype" =~ ^(yaml|yml|json)$ ]]; then
        firstline=$(head -n1 "$file")
        # Check for YAML
        if [[ "$firstline" == "---"* ]]; then
            filetype="yaml"
        # Check for JSON
        elif [[ "$firstline" == "{"* ]]; then
            filetype="json"
        else
            say "[-] Unable to detect the data format as YAML or JSON."
        fi
    fi
}

# Get hostnames from config file
get_hostnames() {
    local config_file=$1
    local filetype=$2

    case "$filetype" in
        yaml|yml)
            # Check if yq is installed
            if ! command -v yq >/dev/null 2>&1; then
                say "[-] yq is not installed."
            fi
            # Extract the names of the hosts from the YAML file
            hostnames=$(yq -r '.hosts[].name' "$config_file")
            ;;
        json)

            # Check if jq is installed
            if ! command -v jq >/dev/null 2>&1; then
                say "[-] jq is not installed."
            fi
            # Extract the host names from the JSON file
            hostnames=$(jq -r '.hosts[].name' "$config_file")
            ;;
        *)
            say "[-] Invalid data format. Only YAML and JSON are supported."
            ;;
    esac

    # Check if hosts are empty
    if [ -z "$hostnames" ]; then
        say "[-] No hosts found in $config_file"
    fi
}

# Check if previous config files exist
check_prev_config() {
    local dir=$1
    if [ -d "$dir" ] && [ "$(ls -A "$dir")" ]; then
        if ! say "[?] Delete previous config files and render again? (y/n)"; then
            say "[+] Exiting..."
            keep_configs=true
            exit 0
        fi
        rm -rf "${dir:?}"/*
    fi
}

# Check if config file is encrypted with sops
check_sops () {
    local file=$1
    local filetype=$2

    # get_hostnames() checks that yq or jq is installed
    # get_filetype() checks that $filetype is yaml, yml or json

    if [[ "$filetype" =~ ^(yaml|yml)$ ]]; then
        # Check if the YAML file is encrypted with SOPS
        if yq -e 'has("sops")' "$file" >/dev/null 2>&1; then
            return 0
        else
            return 1
        fi
    elif [[ "$filetype" == json ]]; then
        # Check if the JSON file is encrypted with SOPS
        if jq -e '.sops | length > 0' "$file" >/dev/null 2>&1; then
            return 0
        else
            return 1
        fi
    else
        say "[-] Invalid data format while checking for encryption."
    fi
}

# Decrypt file encrypted with SOPS
sops_decrypt() {
    local file=$1
    local filetype=$2

    # Check if sops is installed
    if ! command -v sops &> /dev/null; then
        say "[-] Decryption failed, SOPS not installed."
    fi

    # Create a temporary file for the decrypted output
    decrypted_temp_file=$(mktemp)

    # Decrypt file and write output to temporary file
    if ! sops --input-type "$filetype" --output-type "$filetype" -d "$file" > "$decrypted_temp_file"; then
        say "[-] Decryption failed."
    else
        say "[+] Decryption successful."
        config_file="$decrypted_temp_file"
    fi
}

# Build images using nix-build command
build_images() {
    local total_hosts
    total_hosts=$(echo "$hostnames" | wc -w)

    # Check if output directory exists and prompt user if necessary
    if [ -d "$output_dir" ] && [ "$(ls -A "$output_dir")" ]; then
        if ! say "[?] Delete previous images and rebuild? (y/n)"; then
            exit 0
        fi
        rm -rf "${output_dir:?}"/*
    else
        if ! say "[?] Proceed with building? (y/n)"; then
            exit 0
        fi
    fi

    # Start the timer
    SECONDS=0

    # Initialize host building counter
    counter=0

    # Loop through the hosts and build the images
    for host in $hostnames; do
        
        # Print host name
        (( counter++ ))
        say "\n[+] Building images for $host [$counter/$total_hosts]"
        
        # Build images for $host using nix-build command
        if "$verbose"; then
            nix-build \
                -A pix.ipxe "$config_dir"/"$host"/default.nix \
                -I nixpkgs="$NIXPKGS_REPO" \
                -I home-manager="$HM_REPO" \
                -o "$output_dir"/"$host";
        else
            nix-build \
                -A pix.ipxe "$config_dir"/"$host"/default.nix \
                -I nixpkgs="$NIXPKGS_REPO" \
                -I home-manager="$HM_REPO" \
                -o "$output_dir"/"$host" >/dev/null 2>&1 ;
        fi

        # Check if building images for $host was successful
        if [ $? -ne 0 ]; then
            say "[-] Build failed for $host"
            if ! say "[?] Continue? (y/n)"; then
                rm -rf "${output_dir:?}"/"$host"
                say "[+] Exiting..."
                exit 0
            fi
        else
            say "[+] Succesfully built images for $host"
            
            # Print the symlink target paths to the array
            mapfile -t symlink_paths < <(readlink -f "$output_dir"/"$host"/* | sort -u)
            say "\n[+] $host - result"
            for path in "${symlink_paths[@]}"; do
                if "$verbose"; then
                    if [[ "${path}" == "${symlink_paths[-1]}" ]]; then
                        say " └── ${path}"
                    else
                        say " ├── ${path}"
                    fi
                else
                    echo "${path}"
                fi
            done
        fi
    done

    # End the timer
    secs=$SECONDS

    # Print the message with the time in the desired format
    hrs=$(printf "%02d" $((secs/3600)))
    mins=$(printf "%02d" $(((secs/60)%60)))
    secs=$(printf "%02d" $((secs%60)))
    say "\n[+] Build(s) completed in: $hrs:$mins:$secs"
}

# Clean up
cleanup() {
    # Remove mktemp files
    temp_files=("$temp_file" "$decrypted_file")
    for file in "${temp_files[@]}"; do
        if [ -e "$file" ]; then
            rm -f "$file"
        fi
    done

    # Remove configuration files
    if [ -d "$config_dir" ] && [ "$(ls -A "$config_dir")" ] && [ "$keep_configs" == false ]; then
        if ! say "[?] Delete rendered config files? (y/n)"; then
            say "[+] Exiting..."
            exit 0
        fi
        rm -rf "${config_dir:?}"/*
    fi
}

main() {
    # set signal handlers to call cleanup function on exit or SIGINT
    trap cleanup EXIT
    trap cleanup SIGINT

    # Check main dependencies (nix, python, jinja2)
    check_deps

    # Parse the command line options
    parse_args "$@"

    # Check if stdin was piped
    if [[ ! -t 0 ]]; then
        # Get stdin and save to temporary file (sets config_file)
        get_stdin  
        if [[ ${prompt} == true ]]; then
            say "[-] Prompt needs to be disabled when data is piped to the script."
        fi
    fi
    
    # Check if config_file is set and exists
    if [[ -z "$config_file" && ! -e "$config_file" ]]; then
        say "[-] No given configuration data found."
    fi

    # Get filetype (yaml or json)
    get_filetype "$config_file"

    # Get hostnames from config file
    get_hostnames "$config_file" "$filetype"
    
    # Create required directories if they don't exist
    directories=( "$output_dir" "$config_dir" )
    for dir in "${directories[@]}"; do
        mkdir -p "$dir"
    done

    # Check if previous config files exist
    check_prev_config "$config_dir"

    # Decrypt if file is encrypted with SOPS
    if check_sops "$config_file" "$filetype"; then
        sops_decrypt "$config_file" "$filetype"
    fi

    # Render the Nix config files using the python script
    if ! $python_cmd "$SCRIPT_DIR/configs/render_configs.py" "$config_file"; then
        say "[-] Rendering failed."
    fi

    # Print the config paths
    for host in $hostnames; do
        mapfile -t subdir_files < <(find "$config_dir"/"$host" -type f -printf '%P\n')
        say "\n[+] $host - config"
        for path in "${subdir_files[@]}"; do
            if [[ "${path}" == "${subdir_files[-1]}" ]]; then
                say " └── ${path}"
            else
                say " ├── ${path}"
            fi
        done
    done

    # Check if previous build files exists
    build_images
}

main "$@"