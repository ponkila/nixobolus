# Nixobolus - Automated creation of bootable NixOS images
# https://github.com/ponkila/Nixobolus

{#- Defaults #}
{%- set username        = data.user             | default("validator") %}
{%- set hostname        = data.name             | default("") %}
{%- set shell           = data.shell            | default(none) %}
{%- set mounts          = data.mounts           | default(none) %}
{%- set timezone        = data.timezone         | default("Europe/Lisbon") %}
{%- set font            = data.font             | default("monospace") %}
{%- set keymap          = data.keymap           | default("us") %}
{%- set state_version   = data.state_version    | default("22.11") %}
{%- set remote_builder  = data.remote_builder   | default(false) %}

{ pkgs, inputs, config, lib, ... }:
{
    imports = [
        ../../common/channels.nix
        ../../common/ramdisk.nix
        {{ data.rendered_configs | join('\n') | indent(8) }}
    ];

    # Localization
    networking.hostName = "{{ hostname }}";
    time.timeZone = "{{ timezone }}";
    console = {
        font = "{{ font }}";
        keyMap = "{{ keymap }}";
    };

    # User
    services.getty.autologinUser = "{{ username }}";
    users.users.{{ username }} = {
        group = "{{ username }}";
        isNormalUser = true;
        extraGroups = [ "wheel" ];
        {%- if shell %}
        shell = pkgs.{{ shell }};
        {%- endif %}
        # Allow the graphical user to login without password
        initialHashedPassword = "";
    };
    users.groups.{{ username }} = { };
    users.users.root.initialHashedPassword = "";

    # Allow passwordless sudo from wheel group
    security.sudo = {
        enable = lib.mkDefault true;
        wheelNeedsPassword = lib.mkForce false;
    };
    
    nix = {
        # This will add each flake input as a registry
        # To make nix3 commands consistent with your flake
        registry = lib.mapAttrs (_: value: { flake = value; }) inputs;

        # This will additionally add your inputs to the system's legacy channels
        # Making legacy nix commands consistent as well, awesome!
        nixPath = lib.mapAttrsToList (key: value: "${key}=${value.to.path}") config.nix.registry;

        settings = {
            # Enable flakes and new 'nix' command
            experimental-features = "nix-command flakes";
            # Deduplicate and optimize nix store
            auto-optimise-store = true;
            {%- if remote_builder %}
            # Allows this server to be used as a remote builder
            trusted-users = [
                "root"
                "@wheel"
            ];
            {%- endif %}
        };
        package = pkgs.nix;
    };

    {%- if remote_builder %}
    # Allows this server to be used as a remote builder
    nix.settings.trusted-users = [
        "root"
        "@wheel"
    ];
    {%- endif %}

    # Allow emulated systems for cross compile
    boot.binfmt.emulatedSystems = [
        "aarch64-linux"
    ];

    # Boot
    boot.kernelParams = [
        "mitigations=off"
        "l1tf=off"
        "mds=off"
        "no_stf_barrier"
        "noibpb"
        "noibrs"
        "nopti"
        "nospec_store_bypass_disable"
        "nospectre_v1"
        "nospectre_v2"
        "tsx=on"
        "tsx_async_abort=off"
    ];
    boot.kernelPackages = pkgs.linuxPackagesFor (pkgs.linux_latest);

    # System packages
    environment.systemPackages = with pkgs; [
        btrfs-progs
        kexec-tools
        fuse-overlayfs
        lm_sensors
    ];
    
    {%- if mounts %}
    # Mounts
    systemd.mounts = [
    {%- for mount in mounts %}
        {
            enable = true;
            description = "{{ mount.desc or mount.source + "to" + mount.target }}";
            what = "{{ mount.source }}";
            where = "{{ mount.target }}";
            options = "{%- for opt in mount.options %}{{ opt }} {%- endfor %}";
            type = "btrfs";

            wantedBy = [ "multi-user.target" ];
        }
    {%- endfor %}
    ];
    {%- endif %}

    # Linger
    systemd.services.linger = {
        enable = true;

        requires = [ "local-fs.target" ];
        after = [ "local-fs.target" ];

        serviceConfig = {
            Type = "oneshot";
            ExecStart = ''
            /run/current-system/sw/bin/loginctl enable-linger {{ username }}
            '';
        };
        wantedBy = [ "multi-user.target" ];
    };

    # Watchdog
    systemd.watchdog.device = "/dev/watchdog";
    systemd.watchdog.runtimeTime = "30s";

    # Chrony
    services.timesyncd.enable = false;
    services.chrony = {
        enable = true;
        servers = [
            "ntp1.hetzner.de"
            "ntp2.hetzner.com"
            "ntp3.hetzner.net"
        ];
    };

    # Zram swap
    zramSwap = {
        enable = false;
        algorithm = "zstd";
        memoryPercent = 100;
    };

    system.stateVersion = "{{ state_version }}";
}